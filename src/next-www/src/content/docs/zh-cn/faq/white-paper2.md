---
title: 不知道什么标题
description: 不知道怎么描述
---

## 原型的概念的提出

“如何做一个 HCI Protocol”这个问题域太大了，如你所见，即使我们把问题域缩小到“如何创造一个能够满足任何业务需要的前端框架”，我们依旧能得到许多设计理念截然不同的框架。

想让 HCI Protocol 这个想法落地，我们需要一个合适的切入点，比如说尝试对接到在前端/客户端开发中，已经被广泛接受的理念。

这让我立刻想到了”组件化“思想，我们也需要一个基础的抽象单元。如果 HCI Protocol 能直接对接到现有生态的组件上，就能极大缩短落地路径。

接着尝试将组件化思想”去实现化“，因为我们关注的是人机交互本质的抽象，具体的某个技术的组件。所以我们认为，HCI Protocol 应该为大家提供一个类似”组件“的基础复用单元，这在 Proto UI 中被称为 `Prototype`，官方中文为“原型”。如果说前端/客户端开发的核心思路是组件化，那么 Proto UI 对于交互抽象的方式就是“原型化”

## 不是框架、不是 UI 库，更像是一种思想或协议

原型化以及“组件生成”这样的指导方向，进一步的缩小了 Proto UI 要解决的问题域，例如前端框架的问题域是“以某种技术为基础，让其他开发者可以高效的开发 GUI 程序”，而 Proto UI 的问题域缩小为了“如何为交互单元提供准确、高效、可靠的抽象，以及支持把其映射入各种技术”。这带来许多设计理念上的差异，甚至可能有些颠覆常识（前端/客户端方面的）。

1. 最终产物是 Component，而不是 UI

这也是 Proto UI 并不是传统的前端框架，更像是“建模方法”、“编程范式”、“交互协议”的原因。虽然借用了不少前端常见的概念来减少记忆成本，但实际上相差甚远，这里浅举两例：

- Prototype 的参数，实际上更像是 options，用法为 setup 时 `define` 默认值、setup 之后的生命周期中 `get` 实际值，语义上更倾向于 options，甚至无法作为父子原型的通信手段
- Prototype 的状态，并非响应式变量，它的变化不会导致 render 函数执行，只会给元素打上对应的状态机标识；至于是否重绘，取决于是否为该状态提供了单独的样式，这个过程在 Web 是借助 DOM Attribute 和 CSS 实现的。

类似的区别不少，不过由于使用者大部分都不需要参与原型的编写，在非深度定制场景下，学习成本实际很低。

2. 运行效率几乎不取决于 Proto UI，而取决于宿主

鉴于 Proto UI 能落地到框架、平台、甚至硬件，所以 Proto UI 的映射目标被统称为宿主。Proto UI 所映射出的 Flutter 组件，就是 Flutter 原生组件；但你也可以在 Flutter 项目里用 Proto UI 映射 iOS 原生组件，显然性能取决于最后落地的技术。

3. Proto UI 不太适合直接当作跨平台框架

Proto UI 对于框架具体如何进行渲染、事件处理是不关心的，这意味着 Proto UI 默认 API 里完全不负责高性能场景的事件调度，类似于 React Fiber 架构所负责的事情。如果一个不存在额外渲染性能优化的方案，已经能够满足你的需求场景，并且你要落地此应用到数十种技术或平台上（或者较为封闭的内部生态），那你也可以把 Proto UI 作为一种前端/客户端框架来使用，Proto UI 的文档站就是这样实现的（Astro + Proto UI）。

除此之外的情况，显然还是把使用 Proto UI 生成的组件作为基建，而非直接把 Proto UI 当作框架来用，开发体验和性能优化会更好些。
