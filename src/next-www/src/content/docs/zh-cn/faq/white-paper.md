---
title: 组件库的重复开发困境
description: 交互规则稳定，而我们仍在重复发明轮子，并且此代价正在增长
---

在当前的前端与客户端开发中，构建组件库和交互组件的底层能力，仍然充斥着大量重复劳动。以一个最常见的组件——按钮——为例，不论在哪种平台或框架中，它的核心交互规则几乎完全一致：

- **鼠标**：光标移入有反馈，按下与抬起各有反馈；按下-抬起的连续操作视为一次点击
- **键盘**：可被聚焦，聚焦时有样式提示；按 Enter 或 Space 触发点击
- **触屏**：通常仅在按下时有反馈，轻触即视为点击
- **（可选）表单联动**：作为提交触发器
- **（可选）无障碍适配**：如 `aria-label`、`aria-role` 等

这些规则数十年来变化甚微，但每个技术栈都会各自实现一套：React 有 React 的写法，Vue 有 Vue 的写法，Flutter 有 Flutter 的写法，甚至同一技术栈内，不同组件库的实现质量和细节也差异巨大。于是就有了这样的现实：

- 无障碍体验最好的库和视觉设计最合适的库，无法直接融合
- 同一个按钮，在微信小程序、Qt、Flutter 中几乎要“重写三次”
- 跨 Vue2、Vue3、React、Flutter 多端的团队，需要维护多套几乎相同的组件，并在每套里解决一致性问题
- 跨平台的思想不成体系，比如 Headless UI 在 Web 上成型，但在 Qt、Flutter 等平台上只有零散的模仿，无法互通

**交互规则稳定**与**实现割裂**之间的矛盾，正在不断推高开发和维护成本。

---

## 如果交互可以被“协议化”呢？

乍一看，人机交互似乎过于抽象，很难像通信协议那样被标准化；但事实恰好相反——它的稳定性，恰恰为协议化提供了可行性。

- **交互模式的变化速度远慢于技术更迭**：键鼠交互至今仍沿用数十年前的模式，触屏交互也已有十余年未发生根本改变
- **交互概念的跨媒介一致性**：按钮这种交互符号早在人机交互学科诞生之前就已存在，并在不同媒介间保持高度一致
- **现有组件库逻辑高度相似**：只是缺少一套统一的、可机器理解的协议来精确定义

协议化的核心并不是“覆盖更多平台”，而是基于一个更长期的哲学假设：

> **人机交互存在一套长期不变的核心抽象，这套抽象可以被精确定义、被长期积累，并反过来指导不同平台、不同形态的交互实践。**

跨平台只是这种哲学自然产生的副产品，而非唯一目标。

---

## 为什么不是直接用现有的跨平台方案？

面对这个设想，一个常见的疑问是：**跨平台方案已经很多，为什么还要提出新的？现有方案难道不能通过增强或改造来满足需求吗？**

我们先回顾现有跨平台技术的特点：

| 方案类型 | 典型代表 | 核心思路 | 优势 | 局限 |
| --- | --- | --- | --- | --- |
| **运行时桥接** | React Native、Flutter、Electron | 用统一的渲染逻辑驱动多端原生控件 | 跨端一致性较高，生态成熟 | 渲染层与交互层紧耦合，不关注交互规则的长期沉淀 |
| **编译期转译** | Taro、UniApp、Weex | 编译时将统一代码转为多端代码 | 成本低，代码共用率高 | 目标端特性受限，缺乏跨端交互模型的标准化 |
| **虚拟化渲染** | WebGL、Unity、Cocos | 以自渲染引擎接管 UI 与交互 | 完全统一视觉与交互 | 与宿主生态割裂，无法直接复用平台能力 |
| **API 标准化** | W3C 规范、OpenXR、Khronos API | 定义统一接口，由各端实现 | 长期稳定、跨生态 | 多数聚焦底层能力，不覆盖完整 UI 交互模式 |

这些方案有一个共同特点：  
它们解决的是**如何让一套代码在多端运行**，而不是**如何让多端交互规则统一且可演化**。

在这些方案里，交互往往是被“顺带实现”的：

- **React Native/Flutter** 的组件库是运行时自行实现的，逻辑不会反向影响其他平台
- **Taro/UniApp** 在编译期生成的代码，与目标端原有组件库深度绑定，无法沉淀跨端通用逻辑
- **API 标准化** 更多关注硬件/底层接口，并不直接约束按钮、列表、表单等高层交互模式

---

## 协议化方案的核心差异

协议化的目标不是替代上述方案，而是补上它们共同缺失的一层：

> **把交互规则抽象为独立的“协议层”，让它与渲染层、运行时解耦，成为跨平台的长期资产。**

- **独立于运行时与渲染策略**：协议文件只描述交互模型，不关心它最终是用 DOM、Canvas、原生控件还是自渲染引擎实现
- **一次定义，多处落地**：同一份交互协议，可以被多个 Adapter 映射到不同技术栈，而不需要在每个平台重写交互逻辑
- **可演化、可版本化**：协议升级可以向后兼容旧的实现，而不必一次性更新所有平台的代码
- **生态共享**：不同团队可以共享协议层定义和测试用例，而不是只能共享“某个平台的实现代码”

---

## 可行性论证

在提出“交互协议化”这个设想之前，我们需要回答三个问题：

1. **是否有稳定的抽象模型可以承载交互规则？**

   - HTML 的标签语义和 WAI-ARIA 的无障碍标准，已经证明了在 Web 平台上抽象交互是可行的
   - OpenXR、Khronos Group 等跨设备 API 也说明，抽象交互并不局限于单一技术栈

2. **是否有跨平台适配的技术基础？**

   - 现代开发早已习惯用 Adapter 模式桥接差异：React Native、Flutter、Electron、Qt 等技术都在做平台适配
   - 协议化只是把这种桥接提前到“交互定义”层级，让它成为所有实现的统一基准

3. **协议的成本与收益如何？**
   - 成本：需要一次性的建模工作与初期适配器开发
   - 收益：降低多端维护成本、增强一致性、提升生态复用性，并为未来新技术的落地提供即插即用的交互基础

---

## 技术路径（概览）

- **交互模型定义**：用协议文件精确描述组件的结构、事件、状态、样式与可选特性
- **多端 Adapter 实现**：将协议映射到 React、Vue、Flutter、Qt、微信小程序等目标环境
- **向后兼容与演进**：通过协议版本化与兼容层，支持不同代际的交互模型共存
- **生态贡献机制**：任何人都可以扩展协议中的组件定义，并贡献到公共交互资产库

---

接下来，我们将详细拆解**协议化的设计原则**与**实现案例**，展示它在实际开发中如何落地，以及在团队协作与生态构建中的潜力。

## 协议化的设计原则

### 1. 成熟的时机

如今正是推动交互协议化的成熟阶段。  
过去十余年，各种平台和技术对同一交互概念的实现已经积累了海量的经验和范例。  
我们能够参考 React、Vue、Flutter、Qt、Web Components 等不同技术栈中的“按钮”、“列表”、“输入框”等组件实现方式，并将它们的**公共部分抽离**出来。这不仅能直接指导“如何定义交互本质”，更为构建**长期有效的交互模型**提供了坚实的样本库。

同时，这些现有技术所沉淀的**建模方法**（如属性系统、事件绑定、状态管理、生命周期钩子等），也为设计交互本质的“载体”提供了丰富的灵感和借鉴。  
这让我们有机会用更**准确**、更**长远**、更**优雅**的方式定义交互协议。

---

### 2. 设计原则

在抽象交互协议时，我们遵循以下原则：

1. **独立性**  
   协议定义必须独立于具体平台、渲染引擎、运行时框架，不依赖 DOM、Canvas、原生控件等具体实现。  
   它只描述交互的“是什么”，而非“如何画出来”。

2. **可映射性**  
   每个协议定义的交互单元，都可以被精确映射到任意目标平台的实现中。  
   这要求协议的结构具有稳定的字段定义和清晰的事件模型。

3. **可演化性**  
   协议必须支持版本化，允许在保留向后兼容的同时，引入新的交互特性。  
   新旧版本可以在同一生态中共存，降低升级成本。

4. **可测试性**  
   协议定义的每个交互行为，都应当能被统一的测试用例验证。  
   这样可以确保不同平台上的实现保持一致的交互体验。

5. **可扩展性**  
   协议本身应支持第三方扩展，允许团队为自己的业务场景定义新的交互单元，而无需修改核心协议。

---

### 3. 实现方式概览

协议化的落地分为三个核心步骤：

1. **交互模型建模**

   - 分析各平台在同一交互概念上的公共特征
   - 提炼出统一的结构描述（结构树、属性表、事件列表、状态机等）
   - 用中立的描述语言（如 JSON Schema、IDL、或专用 DSL）记录这些定义

2. **Adapter 层实现**

   - 针对每个目标平台（React、Vue、Flutter、Qt 等）编写 Adapter
   - Adapter 接收协议描述，并在平台内生成相应的组件、事件绑定、状态同步逻辑
   - 保证协议到平台实现的映射是可预测、可调试的

3. **协议版本管理与测试体系**
   - 为每个协议定义分配版本号
   - 维护跨平台的交互一致性测试集
   - 对新版本进行回归测试，确保升级不会破坏既有平台的交互表现

---

通过遵循这些原则，我们不仅能够确保交互协议在不同平台上的一致性，还能为未来的新平台、新媒介（如 AR/VR、可穿戴设备）提供即插即用的交互基石。  
这正是交互协议化与传统跨平台方案最大的不同：它追求的是**交互模型的长期稳定和可演化性**，而不仅仅是代码的多端复用。

---

### 4. 原型：协议中的交互本质载体

在 Proto UI 中，交互的本质被称为**「原型」**（Prototype）。  
它是对某一类交互模式的最小完备抽象——不依赖于具体的视觉表现，也不受制于特定平台的实现方式。  
一个按钮原型，不仅描述它的结构、状态和事件，还定义了它在各种输入媒介下的交互规则。  
这意味着，只要协议层面定义了原型，任意平台的实现都可以映射到这一抽象，从而获得一致的行为表现。

---

### 5. 语言策略：不做独立 DSL，支持无损转译

虽然协议化需要一个载体来表达原型，但 Proto UI 在短期内**并不打算设计、开发和维护独立的 DSL**。  
这是基于三个方面的考虑：

1. **协议的逻辑表达力**  
   原型除了结构化数据，还需要表达一定的逻辑（如事件处理、状态计算、条件分支）。  
   单纯的 JSON/Schema 无法承载这些逻辑，而 DSL 至少要支持函数定义和基础运算。

2. **生态与工具链成本**  
   设计 DSL 意味着要为它开发编译器、调试器、IDE 插件等完整工具链，这会分散协议本身的关注点。

3. **与宿主语言模块化体系直接对接**  
   如果原型能够以宿主语言的模块形式存在，就可以直接参与该语言的依赖管理和构建流程，实现**渐进式引入**。  
   这强调了交互协议化作为一种思想，虽然有实质约束，但不应让项目的集成成本骤然上升。  
   例如在 Flutter 项目中，一个按钮原型可能以 `button.proto.dart` 的形式存在，可以直接 `import` 到代码中，然后通过 `Adapter(buttonPrototype)` 即可得到该按钮对应的 `StatefulWidget` 定义。

因此，我们选择让**原型直接附着于现有通用语言**（如 JavaScript/TypeScript、C++、Dart 等任何可能用于构建 UI 的语言）。  
协议本身只定义语义约束，不限定语法。  
官方工具会负责在不同语言之间进行**无损转译**，而无损的前提是：

> 原型的语法保持精简，不依赖语言特有特性，就能被安全地转译到其他语言实现中。

这种方式既避免了 DSL 的高额维护成本，又能让团队在熟悉的语言环境中编写原型，并将其在多种技术栈中落地。

---
